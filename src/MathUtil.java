public class MathUtil {

    /**
     * Этот метод проверят просто ли число если
     * число n просто то выводит true а если нет то false
     */
    public static boolean isPrime(int n) {
//        Prime number больше 1
//        В следующей строке я даю условие что если меньше 1 то это не prime number
        if (n <= 1) {
            return false;
        }
//        В этой строке я проверяю от 2 до числа делиться ли
//        Если делиться то не Prime number а если не делиться то prime number
        for (int i = 2; i < n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Этот метод вычисляет наибольший общий делитель (НОД) двух целых чисел.
     * НОД — это наибольшее число, на которое оба числа делятся без остатка.
     * <p>
     * a Первое целое число.
     * b Второе целое число.
     * return Наибольший общий делитель двух чисел.
     */
    public static int gcd(int a, int b) {
        // Пока b не равно 0, продолжаем вычисления
        while (b != 0) {
            // Сохраняем текущее значение a во временной переменной
            int temp = a;
            // Обновляем a значением b
            a = b;
            // Обновляем b значением остатка от деления temp на b
            b = temp % b;
        }
        // Когда b становится 0, a содержит НОД
        return a;
    }

    /**
     * Этот метод вычисляет наименьшее общее кратное (НОК) двух целых чисел.
     * НОК — это наименьшее число, которое делится на оба числа без остатка.
     * <p>
     * a Первое целое число.
     * b Второе целое число.
     * return Наименьшее общее кратное двух чисел.
     */
    public static int lcm(int a, int b) {
        // Вычисляем НОК с использованием формулы: НОК(a, b) = (a * b) / НОД(a, b)
        return (a * b) / gcd(a, b);
    }

    /**
     * Этот метод генерирует последовательность Фибоначчи до заданного числа n.
     * Последовательность Фибоначчи — это ряд чисел, где каждое число является суммой двух предыдущих.
     * <p>
     * n Максимальное число, до которого будет генерироваться последовательность.
     * return Последнее число в последовательности Фибоначчи, не превышающее n.
     */
    public static int fibonacci(int n) {
        // Начальные значения для последовательности Фибоначчи
        int a = 0, b = 1;
        // Печатаем первое число в последовательности
        System.out.print(a + " ");
        // Генерируем числа Фибоначчи до тех пор, пока b не превысит n
        while (b <= n) {
            // Печатаем текущее число b
            System.out.print(b + " ");
            // Вычисляем следующее число как сумму a и b
            int next = a + b;
            // Обновляем a и b для следующей итерации
            a = b;
            b = next;
        }
        // Возвращаем последнее число в последовательности
        return a;
    }

    /**
     * Этот метод вычисляет факториал целого числа n.
     * Факториал — это произведение всех положительных целых чисел от 1 до n.
     * n Число, для которого необходимо вычислить факториал.
     * return Факториал числа n, или 0, если n отрицательное.
     */
    public static int factorial(int n) {
        // Если n отрицательное, факториал не определен
        if (n < 0) {
            return 0;// Возвращаем 0 для отрицательных чисел
        } else if (n == 0) {
            return 1;// Возвращаем 1 для n = 0
        }
        // Инициализируем переменную для хранения результата
        int result = 1;
        // Вычисляем факториал с помощью цикла
        for (int i = 1; i <= n; i++) {
            result = result * i;// Умножаем result на текущее значение i
        }
        // Возвращаем вычисленный факториал
        return result;
    }

    /**
     * Этот метод проверяет, является ли заданное число совершенным.
     * Совершенное число — это число, равное сумме своих делителей, исключая само себя.
     * <p>
     * n Число, которое необходимо проверить на совершенность.
     * return true, если число совершенное, иначе false.
     */
    public boolean isPerfectNumber(int n) {
        // Переменная для хранения суммы делителей
        int sum = 0;
        // Итерация от 1 до n-1 для нахождения делителей числа n
        for (int i = 1; i < n; i++) {
            // Проверяем, является ли i делителем n
            if (n % i == 0) {
                sum += i;// Если да, добавляем его к сумме
            }
        }
        // Проверяем, равна ли сумма делителей самому числу n
        return sum == n;// Возвращаем true, если число совершенное, иначе false
    }

    /**
     * Этот метод вычисляет сумму цифр целого числа n.
     * Число, для которого необходимо вычислить сумму цифр.
     * return Сумма цифр числа n.
     */
    public int sumOfDigits(int n) {
        // Переменная для хранения суммы цифр
        int sum = 0;
        // Цикл продолжается, пока n не станет равным 0
        while (n != 0) {
            // Добавляем последнюю цифру числа n к сумме
            sum += n % 10;
            // Удаляем последнюю цифру из n
            n = n / 10;
        }
        // Возвращаем вычисленную сумму цифр
        return sum;
    }

    /**
     * Этот метод переворачивает целое число n.
     * <p>
     * n Число, которое необходимо перевернуть.
     * return Перевернутое число.
     */
    public int reverseNumber(int n) {
        // Переменная для хранения перевернутого числа
        int reversed = 0;
        // Цикл продолжается, пока n не станет равным 0
        while (n != 0) {
            // Добавляем последнюю цифру числа n к перевернутому числу
            reversed = reversed * 10 + n % 10;
            // Удаляем последнюю цифру из n
            n = n / 10;
        }
        // Возвращаем перевернутое число
        return reversed;
    }

    /**
     * Этот метод проверяет, является ли заданное число n числом Армстронга.
     * Число Армстронга — это число, равное сумме своих цифр, возведенных в степень количества цифр.
     * <p>
     * n Число, которое необходимо проверить на принадлежность к числам Армстронга.
     * return true, если число является числом Армстронга, иначе false.
     */
    public boolean isArmstrongNumber(int n) {
        // Сохраняем оригинальное значение n для последующего сравнения
        int original = n, sum = 0;// Переменная для хранения суммы
        // Определяем количество цифр в числе n
        int numDigits = String.valueOf(n).length();
        // Цикл продолжается, пока n не станет равным 0
        while (n != 0) {
            // Извлекаем последнюю цифру числа n
            int digit = n % 10;
            // Возводим цифру в степень количества цифр и добавляем к сумме
            sum += Math.pow(digit, numDigits);
            // Удаляем последнюю цифру из n
            n = n / 10;
        }
        // Проверяем, равна ли сумма оригинальному числу
        return sum == original; // Возвращаем true, если n является числом Армстронга, иначе false
    }

    /**
     * Этот метод находит следующее простое число после заданного числа n.
     * <p>
     * n Число, после которого будет найдено следующее простое число.
     * return Следующее простое число после n.
     */
    public int nextPrime(int n) {
        n++;// Увеличиваем n на 1, чтобы начать поиск с следующего числа
        // Цикл продолжается, пока не найдется простое число
        while (!isPrime(n)) {
            n++;// Увеличиваем n до тех пор, пока не найдем простое число
        }
        // Возвращаем найденное простое число
        return n;
    }


}







